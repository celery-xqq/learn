# 33. 搜索旋转排序数组
# 整数数组 nums 按升序排列，数组中的值 互不相同 。

# 在传递给函数之前，nums 在预先未知的某个下标 k（0 <= k < nums.length）上进行了 旋转，
# 使数组变为 [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]（下标 从 0 开始 计数）。
# 例如， [0,1,2,4,5,6,7] 在下标 3 处经旋转后可能变为 [4,5,6,7,0,1,2] 。
# 给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的下标，否则返回 -1 。
# 你必须设计一个时间复杂度为 O(log n) 的算法解决此问题。

# 为了在旋转后的有序数组中高效地找到目标值，我们可以使用改进的二分查找算法。
# 该算法通过判断左右部分的顺序来确定目标值可能存在的区间，从而逐步缩小搜索范围，保持时间复杂度为O(log n)。

# ### 方法思路
# 1. **初始化指针**：使用左右指针`left`和`right`分别指向数组的起始和末尾。
# 2. **二分查找**：计算中间位置`mid`，并检查中间元素是否为目标值。
# 3. **判断有序区间**：
#    - 如果左半部分有序（`nums[left] <= nums[mid]`），判断目标值是否在左半部分范围内，若在则调整右指针，否则调整左指针。
#    - 如果右半部分有序，判断目标值是否在右半部分范围内，若在则调整左指针，否则调整右指针。
# 4. **循环执行**：重复上述步骤直到找到目标值或确定其不存在。

### 解决代码
from typing import List

class Solution:
    def search(self, nums: List[int], target: int) -> int:
        left, right = 0, len(nums) - 1
        while left <= right:
            mid = (left + right) // 2
            if nums[mid] == target:
                return mid
            # 检查左半部分是否有序
            if nums[left] <= nums[mid]:
                # 如果目标在左半部分的范围内
                if nums[left] <= target < nums[mid]:
                    right = mid - 1
                else:
                    left = mid + 1
            else:
                # 右半部分有序，检查目标是否在右半部分的范围内
                if nums[mid] < target <= nums[right]:
                    left = mid + 1
                else:
                    right = mid - 1
        return -1

# ### 代码解释
# - **初始化指针**：`left`和`right`分别初始化为数组的起始和末尾索引。
# - **循环条件**：当`left`指针不超过`right`指针时继续循环。
# - **中间位置计算**：计算中间索引`mid`，并检查该位置元素是否为目标值，若是则直接返回。
# - **判断有序区间**：根据左半部分是否有序来决定如何调整搜索范围：
#   - 左半部分有序时，若目标值在该范围内，调整右指针，否则调整左指针。
#   - 右半部分有序时，若目标值在该范围内，调整左指针，否则调整右指针。
# - **返回结果**：若循环结束仍未找到目标值，返回-1。

# 该算法通过每次将搜索范围减半，保证了时间复杂度为O(log n)，适用于处理旋转后的有序数组查找问题。
