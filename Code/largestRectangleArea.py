# 84. 柱状图中最大的矩形
# 给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。
# 求在该柱状图中，能够勾勒出来的矩形的最大面积。

# 示例 1:
# 输入：heights = [2,1,5,6,2,3]
# 输出：10
# 解释：最大的矩形为图中红色区域，面积为 10

# 示例 2：
# 输入： heights = [2,4]
# 输出： 4

# ------------------------------------------------------------------------------------------------------
# AI思考
# 应该找到每个柱子作为高度，向左右扩展，直到遇到比它矮的柱子，这样就能确定这个高度的最大宽度。然后计算面积，取最大的那个。
# 那问题转化为，对于每个heights[i]，找到左边第一个比它小的位置left，右边第一个比它小的位置right。
# 这样，这个i的高度对应的最大宽度就是right - left -1，面积是heights[i]*(right - left -1)。然后遍历所有i，找到最大值。
# 那现在的问题是，如何高效地找到每个元素的左右边界。如果暴力法的话，对于每个i，向左遍历找到第一个比它小的，右边同理。
# 这样时间复杂度是O(n^2)，在数据量大的时候会超时。比如n是1e5的话，这样肯定不行。
# 那有没有更高效的方法？比如用单调栈。单调栈可以用来处理这类“最近的更小/更大元素”的问题。
# 我记得单调栈的做法通常是维护一个栈，栈中的元素保持单调递增或递减的顺序。当遇到新元素时，弹出栈顶直到满足单调性，同时在这个过程中处理相关逻辑。
# ------------------------------------------------------------------------------------------------------

# 假设我们维护一个单调递增栈，当遇到一个比栈顶元素小的元素时，这个新元素就是栈顶元素的右边界。
# 而栈顶元素的左边界就是栈中的下一个元素。例如，当栈中有元素序列为a, b, c（递增），当前元素d比c小，那么c的右边界是当前索引i，左边界是b的索引。
# 这样，可以计算c的高度对应的面积是height[c] * (i - b.index -1)。这似乎是一个可行的方法。
# ------------------------------------------------------------------------------------------------------

# 为了解决柱状图中最大矩形面积的问题，我们可以使用单调栈来高效地找到每个柱子的左右边界。这种方法的时间复杂度为O(n)，其中n是柱子的数量。

# ### 方法思路
# 1. **单调栈**：维护一个单调递增的栈，栈中保存柱子的索引。当遇到一个柱子高度小于栈顶柱子的高度时，说明找到了栈顶柱子的右边界。
# 2. **左右边界确定**：对于每个柱子，左边界是栈中前一个元素的位置，右边界是当前遍历到的位置。若栈为空，左边界为-1。
# 3. **面积计算**：每次弹出栈顶元素时，计算以该柱子高度为高的最大矩形面积，并更新最大面积。

### 解决代码
from typing import List
class Solution:
    def largestRectangleArea(self, heights: List[int]) -> int:
        max_area = 0
        stack = []
        n = len(heights)
        for i in range(n):
            while stack and heights[i] < heights[stack[-1]]:
                top = stack.pop()
                if stack:
                    width = i - stack[-1] - 1
                else:
                    width = i
                area = heights[top] * width
                max_area = max(max_area, area)
            stack.append(i)
        
        while stack:
            top = stack.pop()
            if stack:
                width = n - stack[-1] - 1
            else:
                width = n
            area = heights[top] * width
            max_area = max(max_area, area)
        
        return max_area

# ### 代码解释
# 1. **初始化**：`max_area`用于记录最大面积，`stack`作为单调递增栈。
# 2. **遍历数组**：对于每个柱子，若当前柱子高度小于栈顶柱子高度，弹出栈顶元素并计算其面积。宽度由当前索引和栈顶元素的位置确定。
# 3. **处理剩余栈元素**：遍历结束后，处理栈中剩余元素，其右边界为数组末尾。
# 4. **返回结果**：最终返回最大面积。

# 该方法高效地利用单调栈确定每个柱子的左右边界，确保了O(n)的时间复杂度，适用于处理大规模数据。

# 比如，示例1的处理过程：

# 初始栈空。

# i=0，栈空，push 0。栈：0（对应高度2）

# i=1，高度1 < 2。弹出0。此时栈空，所以左边界是-1。右边界是i=1。宽度=1-(-1)-1=1。面积=2*1=2。此时max=2。然后push1（高度1）。

# i=2，高度5>1。push2。栈：1,2.

# i=3，高度6>5。push3。栈：1,2,3.

# i=4，高度2 <6。弹出3。此时右边界是i=4，左边界是栈顶的2（高度5）。所以高度6的宽度是4-2-1=1。面积6*1=6。
# 当前max还是2，此时变为6？或者之前的弹出0的时候max是2，然后弹出3的时候得到6，此时max=6。
# 接着，当前元素是4的高度2，与栈顶的2的高度5比较，2<5。继续弹出2。此时右边界是4，左边界是1。
# 所以高度5的宽度是4-1-1=2。面积5*2=10。max变为10。现在栈顶是1的高度1。当前元素4的高度2>1，push4。栈变为1,4.

# i=5，高度3>2。push5。栈：1,4,5.

# 遍历结束后，处理栈中的剩余元素：

# 栈中有元素1,4,5。此时它们的右边界都是n=6。

# 弹出5：左边界是4的索引，右边界6。宽度=6-4-1=1。面积3*1=3。max保持10.

# 弹出4：左边界是1，右边界6。宽度=6-1-1=4。面积2*4=8。max仍10.

# 弹出1：左边界-1，右边界6。宽度6-(-1)-1=6。面积1*6=6。max还是10.

# 所以最大的面积是10。这与示例的结果一致。

# 那这说明，算法的大体思路是维护一个单调递增栈，当遇到比栈顶元素小的元素时，弹出栈顶，并计算以该高度为高的矩形面积。
# 该高度的右边界是当前的i，左边界是栈顶元素的下一个元素。
# 或者更准确地说，当栈顶元素被弹出时，新的栈顶元素就是左边界，所以宽度是i - left -1。
# 其中left是弹出后的栈顶元素。例如，当栈顶元素是k，当遇到i时，弹出k，此时栈顶是j，那么k的左右边界是j和i。
# 所以宽度是i-j-1。对应的面积是heights[k]*(i-j-1)。然后将i入栈。