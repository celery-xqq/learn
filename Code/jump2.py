# 45. 跳跃游戏 II
# 给定一个长度为 n 的 0 索引整数数组 nums。初始位置为 nums[0]。
# 每个元素 nums[i] 表示从索引 i 向后跳转的最大长度。换句话说，如果你在 nums[i] 处，你可以跳转到任意 nums[i + j] 处:
# 0 <= j <= nums[i] 
# i + j < n
# 返回到达 nums[n - 1] 的最小跳跃次数。生成的测试用例可以到达 nums[n - 1]。

# 示例 1:
# 输入: nums = [2,3,1,1,4]
# 输出: 2
# 解释: 跳到最后一个位置的最小跳跃数是 2。
#      从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。
# 示例 2:
# 输入: nums = [2,3,0,1,4]
# 输出: 2

# 为了解决这个问题，我们需要找到从数组起始位置到最后一个位置的最小跳跃次数。
# 我们可以利用贪心算法来高效地解决这个问题，确保在每一步选择最优的跳跃策略，从而减少总跳跃次数。

# ### 方法思路
# 1. **贪心策略**：每次在当前位置能跳到的范围内，选择下一次能跳得最远的位置。这样可以覆盖更多的可能性，从而减少总跳跃次数。
# 2. **关键变量**：
#    - `steps`：记录跳跃次数。
#    - `current_end`：当前跳跃能到达的最远位置。
#    - `max_reach`：在遍历过程中能到达的最远位置。
# 3. **遍历数组**：对于每个位置，更新能到达的最远位置`max_reach`。
# 当遍历到当前跳跃的最远位置`current_end`时，增加跳跃次数，并更新`current_end`为新的最远位置`max_reach`。
# 如果此时`current_end`已经超过或等于最后一个位置，则提前终止循环。

### 解决代码
from typing import List
class Solution:
    def jump(self, nums: List[int]) -> int:
        n = len(nums)
        if n == 1:
            return 0
        steps = 0
        current_end = 0
        max_reach = 0
        for i in range(n):
            max_reach = max(max_reach, i + nums[i])
            if i == current_end:
                steps += 1
                current_end = max_reach
                if current_end >= n - 1:
                    break
        return steps

# ### 代码解释
# 1. **初始化**：处理数组长度为1的特殊情况，直接返回0次跳跃。
# 2. **遍历数组**：逐个位置更新能到达的最远位置`max_reach`。
# 3. **跳跃处理**：当遍历到当前跳跃的最远位置`current_end`时，增加跳跃次数，并更新下一次跳跃的最远位置。
# 如果新的最远位置已经覆盖最后一个位置，提前终止循环。
# 4. **返回结果**：最终的跳跃次数即为所求的最小值。

# 该方法的时间复杂度为O(n)，空间复杂度为O(1)，能够高效地解决问题。
