# 48. 旋转图像
# 给定一个 n × n 的二维矩阵 matrix 表示一个图像。请你将图像顺时针旋转 90 度。
# 你必须在 原地 旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要 使用另一个矩阵来旋转图像。
# 示例 1：
# 输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]
# 输出：[[7,4,1],[8,5,2],[9,6,3]]
# 示例 2：
# 输入：matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]
# 输出：[[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]

# 要将一个 n × n 的二维矩阵顺时针旋转 90 度并原地修改，可以通过分层处理的方法，每次交换四个对应位置的元素来完成旋转。

# ### 方法思路
# 1. **分层处理**：将矩阵分为若干层，从外层到内层逐层处理。每一层由外到内的索引为 k，范围是从 0 到 n//2 - 1。
# 2. **元素交换**：对于每一层中的每个元素，找到其旋转后的对应位置，依次交换四个位置的元素。
# 具体来说，元素的位置 (i, j) 旋转后的位置为 (j, n-1-i)，再旋转后的位置为 (n-1-i, n-1-j)，
# 第三次旋转后的位置为 (n-1-j, i)，第四次旋转回到原位置。
# 3. **循环处理**：对每一层的每个元素，按照上述规律交换四个位置的元素，完成顺时针旋转。

### 解决代码
from typing import List
class Solution:
    def rotate(self, matrix: List[List[int]]) -> None:
        """
        Do not return anything, modify matrix in-place instead.
        """
        n = len(matrix)
        for k in range(n // 2):
            for j in range(k, n - k - 1):
                temp = matrix[k][j]
                matrix[k][j] = matrix[n-1-j][k]
                matrix[n-1-j][k] = matrix[n-1-k][n-1-j]
                matrix[n-1-k][n-1-j] = matrix[j][n-1-k]
                matrix[j][n-1-k] = temp

# ### 代码解释
# 1. **外层循环**：`for k in range(n // 2)` 处理每一层，从最外层到内层。
# 2. **内层循环**：`for j in range(k, n - k - 1)` 处理当前层中的每个元素，排除每层最后一个元素以避免重复处理。
# 3. **元素交换**：依次交换四个位置的元素，使用临时变量 `temp` 保存当前元素的值，确保原地修改的正确性。

# 通过这种方法，每个元素经过四次交换后到达正确的位置，从而完成整个矩阵的顺时针旋转。时间复杂度为 O(n²)，空间复杂度为 O(1)。

# 关键规律
# 分层处理：每一层是一个正方形的“框”，从外到内逐层处理。
# 坐标映射：
# 对于位置 (i,j)，其顺时针旋转 90 度后的位置是 (j, n-1-i)。
# 每次处理四个位置的元素：(i,j) → (j,n-1-i) → (n-1-i,n-1-j) → (n-1-j,i) → (i,j)。
# 原地修改：通过临时变量保存一个值，完成四次交换，无需额外空间。
# 通过这种分步交换，任何 n x n 矩阵都能被原地旋转！