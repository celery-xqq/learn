# 56. 合并区间
# 以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] = [starti, endi] 。
# 请你合并所有重叠的区间，并返回 一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间 。

# 示例 1：
# 输入：intervals = [[1,3],[2,6],[8,10],[15,18]]
# 输出：[[1,6],[8,10],[15,18]]
# 解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].

# 示例 2：
# 输入：intervals = [[1,4],[4,5]]
# 输出：[[1,5]]
# 解释：区间 [1,4] 和 [4,5] 可被视为重叠区间。

# 为了解决合并区间的问题，我们可以通过排序和遍历的方法来合并所有重叠的区间。以下是详细的步骤和实现：

# 方法思路
# 排序区间：首先将所有区间按照起始点进行排序。这样处理时可以确保相邻的区间更容易被检测到是否重叠。

# 遍历合并：遍历排序后的区间，逐个检查当前区间是否与结果列表中的最后一个区间重叠。
# 如果重叠，则合并这两个区间；否则直接将当前区间添加到结果列表中。

from typing import List
class Solution:
    def merge(self, intervals: List[List[int]]) -> List[List[int]]:
        if not intervals:
            return []
        # 按照区间的起始点进行排序
        intervals.sort(key=lambda x: x[0])
        merged = [intervals[0]]
        for current in intervals[1:]:
            last = merged[-1]
            # 如果当前区间的起始点小于等于上一个区间的结束点，说明有重叠
            if current[0] <= last[1]:
                # 合并区间，结束点取两者的最大值
                merged[-1] = [last[0], max(last[1], current[1])]
            else:
                merged.append(current)
        return merged
    
# 代码解释
# 输入检查：首先检查输入的区间列表是否为空，若为空则直接返回空列表。

# 排序：使用 sort 方法按照每个区间的起始点进行升序排序。

# 初始化结果列表：将排序后的第一个区间添加到结果列表 merged 中。

# 遍历合并：从第二个区间开始遍历，检查当前区间是否与结果列表中的最后一个区间重叠。
# 若重叠则合并，否则直接添加到结果列表。

# 这种方法的时间复杂度主要由排序决定，为 O(n log n)，其中 n 是区间的数量。空间复杂度为 O(n)，用于存储结果列表。
# 通过这种方法，我们能够高效地合并所有重叠的区间。