# 739. 每日温度
# 给定一个整数数组 temperatures ，表示每天的温度，返回一个数组 answer ，
# 其中 answer[i] 是指对于第 i 天，下一个更高温度出现在几天后。如果气温在这之后都不会升高，请在该位置用 0 来代替。

# 示例 1:
# 输入: temperatures = [73,74,75,71,69,72,76,73]
# 输出: [1,1,4,2,1,1,0,0]
# 示例 2:
# 输入: temperatures = [30,40,50,60]
# 输出: [1,1,1,0]
# 示例 3:
# 输入: temperatures = [30,60,90]
# 输出: [1,1,0]

# 为了高效地找到每一天之后需要等待多少天才能遇到更高的温度，可以使用单调栈的方法。
# 这种方法通过维护一个单调递减的栈来快速确定每个元素的下一个更大元素的位置。

# ### 方法思路
# 1. **初始化**：创建一个结果数组 `answer`，初始值全部为0，长度与输入数组相同。
# 使用一个栈 `stack` 来保存尚未找到下一个更高温度的元素的索引。
# 2. **遍历数组**：对于每一天的温度，检查当前温度是否大于栈顶元素对应的温度：
#    - 如果是，说明栈顶元素的下一个更高温度就是当前这一天，计算天数差并更新结果数组，然后弹出栈顶元素。
# 重复这一过程直到栈顶元素对应的温度不低于当前温度。
#    - 将当前元素的索引压入栈中，继续处理下一个元素。
# 3. **复杂度分析**：每个元素最多入栈和出栈一次，时间复杂度为 O(n)，空间复杂度为 O(n)。

### 解决代码
from typing import List
class Solution:
    def dailyTemperatures(self, temperatures: List[int]) -> List[int]:
        answer = [0] * len(temperatures)
        stack = []
        for i, t in enumerate(temperatures):
            while stack and temperatures[stack[-1]] < t:
                prev_i = stack.pop()
                answer[prev_i] = i - prev_i
            stack.append(i)
        return answer

# ### 代码解释
# - **初始化结果数组和栈**：`answer` 用于存储最终结果，`stack` 用于保存尚未处理的元素索引。
# - **遍历温度数组**：对于每个温度 `t` 和对应的索引 `i`，检查栈顶元素对应的温度是否小于当前温度 `t`。
#   - 如果是，则弹出栈顶元素 `prev_i`，并计算当前索引 `i` 与 `prev_i` 的差值，更新 `answer[prev_i]`。
#   - 将当前索引 `i` 压入栈中，以便后续处理。
# - **返回结果数组**：处理完所有元素后，返回结果数组 `answer`，其中每个元素表示需要等待的天数，若没有更高温度则为0。