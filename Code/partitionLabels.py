# 763. 划分字母区间
# 给你一个字符串 s 。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。
# 例如，字符串 "ababcc" 能够被分为 ["abab", "cc"]，但类似 ["aba", "bcc"] 或 ["ab", "ab", "cc"] 的划分是非法的。
# 注意，划分结果需要满足：将所有划分结果按顺序连接，得到的字符串仍然是 s 。
# 返回一个表示每个字符串片段的长度的列表。

# 示例 1：
# 输入：s = "ababcbacadefegdehijhklij"
# 输出：[9,7,8]
# 解释：
# 划分结果为 "ababcbaca"、"defegde"、"hijhklij" 。
# 每个字母最多出现在一个片段中。
# 像 "ababcbacadefegde", "hijhklij" 这样的划分是错误的，因为划分的片段数较少。 
# 示例 2：
# 输入：s = "eccbbbbdec"
# 输出：[10]

# 为了解决这个问题，我们需要将字符串划分为尽可能多的片段，使得每个字母最多出现在一个片段中。
# 我们可以通过以下步骤实现这一目标：

# ### 方法思路
# 1. **记录每个字符的最后出现位置**：首先遍历字符串，记录每个字符最后一次出现的位置。
# 2. **维护当前区间的开始和结束位置**：再次遍历字符串，维护当前区间的开始和结束位置。
# 对于每个字符，更新当前区间的结束位置为当前字符的最后出现位置的最大值。
# 当遍历到当前区间的结束位置时，表示当前区间可以分割，记录该区间的长度，并重置下一个区间的开始位置。

### 解决代码
def partitionLabels(s):
    last_pos = {}
    for i, c in enumerate(s):
        last_pos[c] = i
    
    res = []
    start = end = 0
    for i, c in enumerate(s):
        end = max(end, last_pos[c])
        if i == end:
            res.append(end - start + 1)
            start = end + 1
    return res

# ### 代码解释
# 1. **记录字符最后出现的位置**：使用字典 `last_pos` 来存储每个字符在字符串中的最后出现位置。
# 遍历字符串时，更新每个字符的最后位置。
# 2. **遍历字符串确定分割点**：初始化 `start` 和 `end` 为0，分别表示当前区间的起始和结束位置。
# 遍历字符串时，不断更新 `end` 为当前字符的最后出现位置的最大值。
# 当遍历到 `end` 位置时，表示当前区间结束，记录区间长度，并将 `start` 设置为下一个区间的起始位置。

# 这种方法确保每个字符只出现在一个片段中，并且划分的片段数尽可能多，时间复杂度为O(n)，空间复杂度为O(1)（字符集大小为常数）。
