# 153. 寻找旋转排序数组中的最小值
# 已知一个长度为 n 的数组，预先按照升序排列，经由 1 到 n 次 旋转 后，得到输入数组。例如，原数组 nums = [0,1,2,4,5,6,7] 在变化后可能得到：
# 若旋转 4 次，则可以得到 [4,5,6,7,0,1,2]
# 若旋转 7 次，则可以得到 [0,1,2,4,5,6,7]
# 注意，数组 [a[0], a[1], a[2], ..., a[n-1]] 旋转一次 的结果为数组 [a[n-1], a[0], a[1], a[2], ..., a[n-2]] 。
# 给你一个元素值 互不相同 的数组 nums ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 最小元素 。
# 你必须设计一个时间复杂度为 O(log n) 的算法解决此问题。

# 示例 1：
# 输入：nums = [3,4,5,1,2]
# 输出：1
# 解释：原数组为 [1,2,3,4,5] ，旋转 3 次得到输入数组。

# 示例 2：
# 输入：nums = [4,5,6,7,0,1,2]
# 输出：0
# 解释：原数组为 [0,1,2,4,5,6,7] ，旋转 4 次得到输入数组。

# 示例 3：
# 输入：nums = [11,13,15,17]
# 输出：11
# 解释：原数组为 [11,13,15,17] ，旋转 4 次得到输入数组。

from typing import List
# 要找到旋转排序数组中的最小元素，可以使用二分查找算法。旋转后的数组分为两部分，都是升序，且左边部分的元素都大于右边部分的元素。
# 通过比较中间元素和右边界元素，可以确定最小值的位置。

# ### 方法思路
# 1. **初始化指针**：左指针`left`指向数组起始位置，右指针`right`指向数组末尾。
# 2. **二分查找**：在每次循环中，计算中间位置`mid`。
#    - 如果`nums[mid] > nums[right]`，说明中间元素位于左半部分，最小值在右侧，移动`left`到`mid + 1`。
#    - 否则，中间元素位于右半部分或本身就是最小值，移动`right`到`mid`。
# 3. **终止条件**：当`left`等于`right`时，找到最小值，返回`nums[left]`。

### 解决代码
class Solution:
    def findMin(self, nums: List[int]) -> int:
        left, right = 0, len(nums) - 1
        while left < right:
            mid = (left + right) // 2
            if nums[mid] > nums[right]:
                left = mid + 1
            else:
                right = mid
        return nums[left]

# ### 代码解释
# - **初始化指针**：`left`和`right`分别初始化为0和数组末尾索引。
# - **循环条件**：当`left`小于`right`时继续循环，确保每次范围缩小。
# - **中间位置计算**：使用整数除法计算中间位置`mid`。
# - **比较与调整指针**：通过比较中间元素和右边界元素，调整左右指针的位置，缩小搜索范围。
# - **返回结果**：当循环结束时，`left`和`right`指向最小值，返回`nums[left]`。
# 该算法的时间复杂度为O(log n)，符合题目要求。

sol = Solution()
list1=[2,1]
print(sol.findMin(list1))